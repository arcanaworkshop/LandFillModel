#include "Arduino.h"

#include <SD.h>                      // need to include the SD library
#include <TMRpcm.h>           //  also need to include this library...
#include <SPI.h>
#define SD_ChipSelectPin 10  //using digital pin 4 on arduino nano 328, can use other pins

TMRpcm tmrpcm;   // create an object for use in this sketch


// Debug mode
// #define DEBUG165
// #define DEBUG595
// #define DEBUGSD

/* How many shift register chips are daisy-chained.
*/
#define NUMBER_OF_SHIFT_CHIPS   2

/* Width of data (how many ext lines).
*/
#define DATA_WIDTH   NUMBER_OF_SHIFT_CHIPS * 8

/* Width of pulse to trigger the shift register to read and latch.
*/
#define PULSE_WIDTH_USEC   5

/* Optional delay between shift register reads.
*/
#define POLL_DELAY_MSEC   5

unsigned long previous_time = 0;
unsigned long current_time;
unsigned long buttonOnAtTime = 0;

#define BYTES_VAL_T unsigned int

int ploadPin        = 5;  // Connects to Parallel load pin the 165
int clockEnablePin  = 6;  // Connects to Clock Enable pin the 165
int dataPin         = 7; // Connects to the Q7 pin the 165
int clockPin        = 8; // Connects to the Clock pin the 165

int latchPin595 = 4; // ST_CP of 595
int clockPin595 = 3; // SH_CP of 595
int dataPin595 = 2; // DS of 595

BYTES_VAL_T pinValues;
BYTES_VAL_T oldPinValues;

boolean ledState = false;

unsigned long LED_on_interval = 4000; // time for led to stay lit

/* This function is essentially a "shift-in" routine reading the
 * serial Data from the shift register chips and representing
 * the state of those pins in an unsigned integer (or long).
*/
BYTES_VAL_T read_shift_regs()
{
    long bitVal;
    BYTES_VAL_T bytesVal = 0;

    /* Trigger a parallel Load to latch the state of the data lines,
    */
    digitalWrite(clockEnablePin, HIGH);
    digitalWrite(ploadPin, LOW);
    delayMicroseconds(PULSE_WIDTH_USEC);
    digitalWrite(ploadPin, HIGH);
    digitalWrite(clockEnablePin, LOW);

    /* Loop to read each bit value from the serial out line
     * of the SN74HC165N.
    */
    for(int i = 0; i < DATA_WIDTH; i++)
    {
        bitVal = digitalRead(dataPin);

        /* Set the corresponding bit in bytesVal.
        */
        bytesVal |= (bitVal << ((DATA_WIDTH-1) - i));

        /* Pulse the Clock (rising edge shifts the next bit).
        */
        digitalWrite(clockPin, HIGH);
        delayMicroseconds(PULSE_WIDTH_USEC);
        digitalWrite(clockPin, LOW);
    }

    return(bytesVal);
}

void myShiftOut(int myDataPin, int myClockPin, byte myDataOut) {
  // This shifts 8 bits out MSB first, 
  //on the rising edge of the clock,
  //clock idles low

  //internal function setup
  int i=0;
  int pinState;
  pinMode(myClockPin, OUTPUT);
  pinMode(myDataPin, OUTPUT);

  //clear everything out just in case to
  //prepare shift register for bit shifting
  digitalWrite(myDataPin, 0);
  digitalWrite(myClockPin, 0);

  //for each bit in the byte myDataOutï¿½
  //NOTICE THAT WE ARE COUNTING DOWN in our for loop
  //This means that %00000001 or "1" will go through such
  //that it will be pin Q0 that lights. 
  for (i=7; i>=0; i--)  {
    digitalWrite(myClockPin, 0);

    //if the value passed to myDataOut and a bitmask result 
    // true then... so if we are at i=6 and our value is
    // %11010100 it would the code compares it to %01000000 
    // and proceeds to set pinState to 1.
    if ( myDataOut & (1<<i) ) {
      pinState= 1;
    }
    else {	
      pinState= 0;
    }

    //Sets the pin to HIGH or LOW depending on pinState
    digitalWrite(myDataPin, pinState);
    //register shifts bits on upstroke of clock pin  
    digitalWrite(myClockPin, 1);
    //zero the data pin after shift to prevent bleed through
    digitalWrite(myDataPin, 0);
  }

  //stop shifting
  digitalWrite(myClockPin, 0);
}

/* Dump the list of zones along with their current status.
*/

boolean writeLED(int ledNum){
  int i = 0;
  int j = 0;
  boolean ledState = false;
  if (ledNum == 0){
    i = 0;
    j = 0;
  }
  else if (ledNum >=256){
    int k = ledNum >> 8;
    j = k-256;
    ledState = true;
  }
  else{
    i = ledNum-256;
    ledState = true;
  }

  digitalWrite(latchPin595, 0);

  myShiftOut(dataPin595, clockPin595, j); // second register
  myShiftOut(dataPin595, clockPin595, i); // first register

  digitalWrite(latchPin595, 1);

  return ledState;
}

void setup()
{
    

    /* Initialize our digital pins...
    */
    pinMode(ploadPin, OUTPUT);
    pinMode(clockEnablePin, OUTPUT);
    pinMode(clockPin, OUTPUT);
    pinMode(dataPin, INPUT);

    pinMode(latchPin595, OUTPUT);

    digitalWrite(clockPin, LOW);
    digitalWrite(ploadPin, HIGH);
    
    // Go through LEDs upon startup to test all LEDs
    for(int i=0; i<=11; i+=1){
      writeLED(1<<i);
      delay(750);
      writeLED(0);
    }

    tmrpcm.speakerPin = 9; // define speaker pin
    tmrpcm.volume(6);
    // if sd initialization works, light up LED at address 4
    if(SD.begin(SD_ChipSelectPin)){
      writeLED(4);
      delay(2000);
      writeLED(0);
    }
    // if sd initialization fails, light up LED at address 8
    else if(!SD.begin(SD_ChipSelectPin)){
      writeLED(8);
      delay(2000);
      writeLED(0);
    }


}

void loop()
{
    current_time = millis();
    pinValues = read_shift_regs();

    if (((unsigned long)(current_time - previous_time)> POLL_DELAY_MSEC)&& (pinValues!=0)){
        pinValues = read_shift_regs();
        buttonOnAtTime = millis();
        switch(pinValues){
          case 1:
            tmrpcm.play("audio1.wav");
            ledState = writeLED(pinValues);
            break;
          case 2:
            tmrpcm.play("audio2.wav");
            ledState = writeLED(pinValues);
            break;
          case 4:
            tmrpcm.play("audio3.wav");
            ledState = writeLED(pinValues);
            break;
          case 8:
            tmrpcm.play("audio4.wav");
            ledState = writeLED(pinValues);
            break;
          case 16:
            tmrpcm.play("audio5.wav");
            ledState = writeLED(16);
            break;
          case 32:
            tmrpcm.play("audio6.wav");
            ledState = writeLED(32);
            break;
          case 64:
            tmrpcm.play("audio7.wav");
            ledState = writeLED(64);
            break;
          case 128:
            tmrpcm.play("audio8.wav");
            ledState = writeLED(128);
            break;
          case 256:
            tmrpcm.play("audio9.wav");
            ledState = writeLED(pinValues);
            break;
          case 512:
            tmrpcm.play("audio10.wav");
            ledState = writeLED(pinValues);
            break;
          case 1024:
            tmrpcm.play("audio11.wav");
            ledState = writeLED(pinValues);
            break;
          case 2048:
            tmrpcm.play("audio12.wav");
            ledState = writeLED(pinValues); 
            break;
          
        }
    }

    if (ledState || (!ledState && tmrpcm.isPlaying())){
    unsigned long currentMillis = millis();
    if ((unsigned long)(currentMillis - buttonOnAtTime) >= LED_on_interval){
      ledState = writeLED(0); // write all LEDS off
    }
  }
    
}
