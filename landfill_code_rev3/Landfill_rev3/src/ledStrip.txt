/**
 * George Spearing
 * Revision 3 of Landfill Model Code
 * 8 Buttons for user input. Play one audio file and light
 * up one section of the model. One LED always lit
 * February 26, 2020
 */

#include <Arduino.h>
#include <Adafruit_NeoPixel.h>


#include <SD.h>                      // need to include the SD library
#include <TMRpcm.h>           //  also need to include this library...
#include <SPI.h>
#define SD_ChipSelectPin 10  //using digital pin 4 on arduino nano 328, can use other pins

TMRpcm tmrpcm;   // create an object for use in this sketch


#define yellow_pin 2
#define red_pin 3
#define STRIP_PIN 4
#define LED_COUNT 4

Adafruit_NeoPixel strip(LED_COUNT, STRIP_PIN, NEO_GRB + NEO_KHZ800);

// Define 74hc165 Pins
/* How many shift register chips are daisy-chained.
*/
#define NUMBER_OF_SHIFT_CHIPS   1

/* Width of data (how many ext lines).
*/
#define DATA_WIDTH   NUMBER_OF_SHIFT_CHIPS * 8

/* Width of pulse to trigger the shift register to read and latch.
*/
#define PULSE_WIDTH_USEC   5

/* Optional delay between shift register reads.
*/
#define POLL_DELAY_MSEC   5

#define BYTES_VAL_T unsigned int

int ploadPin        = 5;  // Connects to Parallel load pin the 165
int clockEnablePin  = 6;  // Connects to Clock Enable pin the 165
int dataPin         = 7; // Connects to the Q7 pin the 165
int clockPin        = 8; // Connects to the Clock pin the 165

BYTES_VAL_T pinValues;
BYTES_VAL_T oldPinValues;

boolean ledState = false;

unsigned long LED_on_interval = 4000; // time for led to stay lit

// timmer memory
unsigned long previous_time = 0;
unsigned long current_time;
unsigned long buttonOnAtTime = 0;

BYTES_VAL_T read_shift_regs()
{
    long bitVal;
    BYTES_VAL_T bytesVal = 0;

    /* Trigger a parallel Load to latch the state of the data lines,
    */
    digitalWrite(clockEnablePin, HIGH);
    digitalWrite(ploadPin, LOW);
    delayMicroseconds(PULSE_WIDTH_USEC);
    digitalWrite(ploadPin, HIGH);
    digitalWrite(clockEnablePin, LOW);

    /* Loop to read each bit value from the serial out line
     * of the SN74HC165N.
    */
    for(int i = 0; i < DATA_WIDTH; i++)
    {
        bitVal = digitalRead(dataPin);

        /* Set the corresponding bit in bytesVal.
        */
        bytesVal |= (bitVal << ((DATA_WIDTH-1) - i));

        /* Pulse the Clock (rising edge shifts the next bit).
        */
        digitalWrite(clockPin, HIGH);
        delayMicroseconds(PULSE_WIDTH_USEC);
        digitalWrite(clockPin, LOW);
    }

    return(bytesVal);
}

void setup() {

  // Initialize our digital pins...
  pinMode(ploadPin, OUTPUT);
  pinMode(clockEnablePin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, INPUT);

  // set initial state of register
  digitalWrite(clockPin, LOW); 
  digitalWrite(ploadPin, HIGH);

  // set state of two LEDs
  pinMode(yellow_pin, OUTPUT);  
  pinMode(red_pin, OUTPUT);

  // start tmrpcm
  tmrpcm.speakerPin = 9; // define speaker pin
  tmrpcm.volume(6);

  // test and start SD Card
  SD.begin(SD_ChipSelectPin);

  // start neo pixel string
  strip.begin();
  strip.show();

}

void loop() {
  current_time = millis();
  pinValues = read_shift_regs();

  if (((unsigned long)(current_time - previous_time)> POLL_DELAY_MSEC)&& (pinValues!=0)){
      pinValues = read_shift_regs();
      buttonOnAtTime = millis();
      switch(pinValues){
        case 1:
          strip.setPixelColor(3,255,0,0);
          strip.show();
          ledState = true;
          break;
        case 2:
          strip.setPixelColor(3,0,255,0);
          strip.show();
          ledState = true;
      }
  }

  if (ledState || (!ledState && tmrpcm.isPlaying())){
    unsigned long currentMillis = millis();
    if ((unsigned long)(currentMillis - buttonOnAtTime) >= LED_on_interval){
      strip.setPixelColor(3,0,0,255); // write all LEDS off
      strip.show();
      ledState = false;
    }
  }

}